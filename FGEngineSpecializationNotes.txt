FG ENGINE SPECIALIZATION COURSE

================================
course plan
================================

this year is new plan

3 weeks intro - Martin

4 weeks ui - Emil
	will do some asset manager stuff.
4 weeks rendering - Emil

1 week physics - Martin

4 weeks make a game in engine! - Martin + Oscar

VG
	deferred rendering
================================
RESOURCES
================================
	BOOKS
		Jason Gregory - Game Engine Architecture , should be third edition or later
		Learning Modern 3d Graphics Programming https://paroj.github.io/gltut/

	Glossary stuff for computer graphics

	GLFW 
		api for opening windows on windows
		https://www.glfw.org/documentation.html#example-code
		https://www.glfw.org/docs/3.3/group__window.html#ga24e02fbfefbb81fc45320989f8140ab5
		
		buffers: GL_DEPTH_BUFFER_BIT, GL_COLOR_BUFFER_BIT

	GLAD
		https://glad.dav1d.de/
	IMGU
		https://github.com/ocornut/imgui
		ui etc will be with this, also check out imgui docking branch for actually modern dockable editor windows.
		
	OPENGL 
		4.6 850 pages of specification https://registry.khronos.org/OpenGL-Refpages/gl4/
		4.5 quick ref https://www.khronos.org/files/opengl45-quick-reference-card.pdf

		LearnOpenGL https://learnopengl.com/Getting-started/OpenGL
		Modern OpenGL Tutorials

	VULKAN
	https://docs.vulkan.org/tutorial/latest/00_Introduction.html

	OTHER PPLS ENGINES
	Zenith Engine has interesting structure for render passes https://github.com/gitbetter/Zenith/tree/master
	hazel engine
================================
DAY 1
================================

Intro
- theory 
- reading
- choose a graphics api. 
- goal is to have a solid base for the ui and rendering time with Emil to build from

WEEK 1 triangle with vertex colors
Week 2 3d with basic textures, hot reloading shaders
WEEK 3 make sure there's a renderer and can rotate the cube, maybe some frame buffer stuff. parenting of objects. loading in an fbx.


GRAPHICS API
course focuses OpenGl but theory is applicable to all
Vulkan is probably a good one if you already know openGL and is more futureproof.
hazel code is worth reading about

BE CURIOUS
look things up as much as you want

COLLABORATE
 pls make a study group!
 share progress, ask for help, inspire eachother

 Martin will show his architecture and explain why he choses the architecture he does.


 WHAT ARE GAME ENGINES
 engines are for making games

 for example unity's graphics engine uses a lot of apis because they want to run on a lot of platforms.

 LAYERS LAYERS LAYERS

 front end, editor, and final game
 back end, engine, physics layer, graphics layer

 abstraction and encapsulation is very important for engine development
 there will be A LOT of layers before we're done

 always think about how painful is a thing to change in the future
 if it's very painful, should probably rethink the plan and change it to be more change friendly

 WHY LEARN ENGINE
 deeper understanding of back end - get very solid c++ skills
 better understanding of hardware
 deeper understanding of tools - one of students last year : the more advanced you become as a gameplay programer the more of a tools programmer you become.
 better understanding of graphics
 better understanding of optimization
 potential for innovative games
 sought after roles in the industry
		even during layoffs engine devs are often the last to be cut


openGL is more like a specification than an api, made by Khronos Group, who also make Vulkan
	
	it doesn't give a lot of classes, mostly functions and enum flags.
	it's very bare bones way of sending comands to the gpu
	is considered easy starting point for engine rendering

	mostly functions with input and output.

SPECIFICATION = long list of functions, a description of the functionality that a program is required to perform
API = also has classes and structural things, often used to communicate with someone else's whole project

OpenGL 
	we call openGL functions, openGL then sends things to the gpu, and the gpu has libraries for different versions of openGL

	on the topic of structure there's a book by Jason Gregory called Game Engine Architecture is very very good

	works like a state machine

	each state of openGL defined as context

	we change to a specific context with variables and run functions.

	eg want to make a change on a texture
	so first you bind the thing, and do the changes to it, then unbind

Time to see some code

opengl 
	NORMALIZED DEVICE COORDINATES 0,0 is at the center of the window context

	// messy oldfashiond bad way of rendering
		glBegin(GL_TRIANGLES);

		glVertex2f(0.5f, 0.0f);
		glVertex2f(0.0f, 0.5f);
		glVertex2f(-0.5f, 0.0f);

		glEnd();

	we will not be using this ultimately as it's obviously not extensible,
	however the glBegin() and glEnd() wrapping the actual rendering is similar to what we will be doing

================================
DAY 2
================================

- installing glad 
- going over core openGL set up and getting the triangle via shaders
- refactoring the learn openGL hello triangle tutorial 
	to have separated classes to better prep for building our engine
- brief confusion about whether or not our vertex should be passing 
	color data through to the fragment shader, mostly brought on 
	by Martin's error detection going wonky

================================
DAY 3
================================
- actually doing color in our renderer
- setting up renderer structures and interfaces
- 
STUCTURE IS REALLY FREAKING IMPORTANT
	some philosophy

	Build systems with change in mind. 
	you will be going back and changing things along the way,
	make it easy on yourself

	the more itteration without specific goals in mind at the begining
	the more spaghetti code you get

	DON'T TRY TO MAKE AN EVERYTHING ENGINE

rough plan
part 1 - forward renderer, one shader, simple render pass (week 1 through 3)
part 2 - forward renderer +, more shaders and shadows, render pass and shadow pass
part 3 - deffered renderer, g buffer intro, geometry and lighting pass

STARTING STRUCTURES
	AssetLoader class
	Renderer class
	Render pass class
	frame buffer class - helpful for docking and deffered rendering
	shader, texture , and renderable classes
	Scene class - contains all renderables
	Camera class - scene will have a main camera that will determine what way things get rendered
	Engine context - a place to reference the various parts of the engine that we might need to coordinate between

VERTEX COLOR THE TRIANGLE TIME

================================
DAY 4 (week 2)
================================
- SQUARE 
	index buffer, and transforms
- CUBE