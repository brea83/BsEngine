FG ENGINE SPECIALIZATION COURSE

================================
course plan
================================

this year is new plan

3 weeks intro - Martin

4 weeks ui - Emil
	will do some asset manager stuff.
4 weeks rendering - Emil

1 week physics - Martin

4 weeks make a game in engine! - Martin + Oscar

VG
	deferred rendering
================================
RESOURCES
================================
	BOOKS
		Jason Gregory - Game Engine Architecture , should be third edition or later
		Learning Modern 3d Graphics Programming https://paroj.github.io/gltut/

	Glossary stuff for computer graphics

	GLFW 
		api for opening windows on windows
		https://www.glfw.org/documentation.html#example-code
		https://www.glfw.org/docs/3.3/group__window.html#ga24e02fbfefbb81fc45320989f8140ab5
		
		buffers: GL_DEPTH_BUFFER_BIT, GL_COLOR_BUFFER_BIT

	GLAD
		https://glad.dav1d.de/
	IMGU
		https://github.com/ocornut/imgui
		ui etc will be with this, also check out imgui docking branch for actually modern dockable editor windows.
		
	OPENGL 
		4.6 850 pages of specification https://registry.khronos.org/OpenGL-Refpages/gl4/
		4.5 quick ref https://www.khronos.org/files/opengl45-quick-reference-card.pdf

		LearnOpenGL https://learnopengl.com/Getting-started/OpenGL
		Modern OpenGL Tutorials

	VULKAN
	https://docs.vulkan.org/tutorial/latest/00_Introduction.html

	ENTT
		entity component library https://github.com/skypjack/entt
	OTHER PPLS ENGINES
	Zenith Engine has interesting structure for render passes https://github.com/gitbetter/Zenith/tree/master
	hazel engine
	
	VIDEOS
	projection matrix https://www.youtube.com/watch?v=U0_ONQQ5ZNM
================================
LECTURE 1
================================

Intro
- theory 
- reading
- choose a graphics api. 
- goal is to have a solid base for the ui and rendering time with Emil to build from

WEEK 1 triangle with vertex colors
Week 2 3d with basic textures, hot reloading shaders
WEEK 3 make sure there's a renderer and can rotate the cube, maybe some frame buffer stuff. parenting of objects. loading in an fbx.


GRAPHICS API
course focuses OpenGl but theory is applicable to all
Vulkan is probably a good one if you already know openGL and is more futureproof.
hazel code is worth reading about

BE CURIOUS
look things up as much as you want

COLLABORATE
 pls make a study group!
 share progress, ask for help, inspire eachother

 Martin will show his architecture and explain why he choses the architecture he does.


 WHAT ARE GAME ENGINES
 engines are for making games

 for example unity's graphics engine uses a lot of apis because they want to run on a lot of platforms.

 LAYERS LAYERS LAYERS

 front end, editor, and final game
 back end, engine, physics layer, graphics layer

 abstraction and encapsulation is very important for engine development
 there will be A LOT of layers before we're done

 always think about how painful is a thing to change in the future
 if it's very painful, should probably rethink the plan and change it to be more change friendly

 WHY LEARN ENGINE
 deeper understanding of back end - get very solid c++ skills
 better understanding of hardware
 deeper understanding of tools - one of students last year : the more advanced you become as a gameplay programer the more of a tools programmer you become.
 better understanding of graphics
 better understanding of optimization
 potential for innovative games
 sought after roles in the industry
		even during layoffs engine devs are often the last to be cut


openGL is more like a specification than an api, made by Khronos Group, who also make Vulkan
	
	it doesn't give a lot of classes, mostly functions and enum flags.
	it's very bare bones way of sending comands to the gpu
	is considered easy starting point for engine rendering

	mostly functions with input and output.

SPECIFICATION = long list of functions, a description of the functionality that a program is required to perform
API = also has classes and structural things, often used to communicate with someone else's whole project

OpenGL 
	we call openGL functions, openGL then sends things to the gpu, and the gpu has libraries for different versions of openGL

	on the topic of structure there's a book by Jason Gregory called Game Engine Architecture is very very good

	works like a state machine

	each state of openGL defined as context

	we change to a specific context with variables and run functions.

	eg want to make a change on a texture
	so first you bind the thing, and do the changes to it, then unbind

Time to see some code

opengl 
	NORMALIZED DEVICE COORDINATES 0,0 is at the center of the window context

	// messy oldfashiond bad way of rendering
		glBegin(GL_TRIANGLES);

		glVertex2f(0.5f, 0.0f);
		glVertex2f(0.0f, 0.5f);
		glVertex2f(-0.5f, 0.0f);

		glEnd();

	we will not be using this ultimately as it's obviously not extensible,
	however the glBegin() and glEnd() wrapping the actual rendering is similar to what we will be doing

================================
LECTURE 2
================================

- installing glad 
- going over core openGL set up and getting the triangle via shaders
- refactoring the learn openGL hello triangle tutorial 
	to have separated classes to better prep for building our engine
- brief confusion about whether or not our vertex should be passing 
	color data through to the fragment shader, mostly brought on 
	by Martin's error detection going wonky

================================
LECTURE 3
================================
- actually doing color in our renderer
- setting up renderer structures and interfaces
- 
STUCTURE IS REALLY FREAKING IMPORTANT
	some philosophy

	Build systems with change in mind. 
	you will be going back and changing things along the way,
	make it easy on yourself

	the more itteration without specific goals in mind at the begining
	the more spaghetti code you get

	DON'T TRY TO MAKE AN EVERYTHING ENGINE

rough plan
part 1 - forward renderer, one shader, simple render pass (week 1 through 3)
part 2 - forward renderer +, more shaders and shadows, render pass and shadow pass
part 3 - deffered renderer, g buffer intro, geometry and lighting pass

STARTING STRUCTURES
	AssetLoader class
	Renderer class
	Render pass class
	frame buffer class - helpful for docking and deffered rendering
	shader, texture , and renderable classes
	Scene class - contains all renderables
	Camera class - scene will have a main camera that will determine what way things get rendered
	Engine context - a place to reference the various parts of the engine that we might need to coordinate between

VERTEX COLOR THE TRIANGLE TIME

================================
LECTURE 4 (week 2)
================================
- SQUARE 
	index buffer, and transforms

	first going over how to use an array of indicies to navigate the raw verticies collection 
	and get all the unique triangles needed to make a square without duplicating two of the verts

	brief intro to linear transformations

- CUBE
================================
LECTURE 5 (week 2)
================================
CAMERA

holds view and projection matrix in Martin's engine
projection doesn't need to be on the camera, but does need to get field of view from the camera

// note to look up what projection matrixes were for other consoles, 
// ps1 for example doesn't do the the final divide be w step

WALK THROUGH OF CAMERA AND SCENE of Martin's engine
	reminder that can init glm:vec3 etc with a single number if all values are supposed to match

================================
LECTURE 6 (week 2)
================================
MODULE ONE REQUIREMENTS
	a cube rendered in a window with perspective
	cube is textured
	cube can be rotated, translated, and scaled with imgui
PREP FOR IMGUI
	object in scene is going to need functions to interact with its component parts via imgui
	a toggle for whether to render imgui stuff (like ent≈ering play mode)
IMGUI
	docking will require framebuffering

	init glfwwindow first
	then set up imgui

	imgui programming goes between imgui::begin and imgui::end() calls

	heirarchy class
	class for object entry or something like inspector

ABOUT FRAME BUFFER	
	viewport has the framebuffer
================================
LECTURE 7 (week 3)
================================

this week's goals
G
	cube rendered in window with perspective
	imgui implemented
	cube can be rotated, translated, and scaled using imgui
	cube is textured.

bonus goals
	stuff that will make the rest of the engine easier to work on
	imgui stuff is all in an editor context

	expect asset loader to be refactored soon
		
	hot reloading a shader
		// asset viewer	
		shows unordered map of loaded resources

		so there's a base class resource
		shader resource adds a recompile function
			takes in a | dilineated string of the two paths to each part of the shader code

			includes early returns as a safety to not overwrite the old shader if the shader can't compile
		texture resource adds mipmap settings
			add enums of the settings to the texture class
			abstract creation of texture into its own function that can be called both in the constructer and by inspector
		
		asset viewer 
		switches based on resource type to build the right inspectors

		think about ways to abstract and reuse parts of the imgui editor code for all the inspectors

		Model/mesh needs to be separated from renderable so that several renderables can reference the same mesh loaded only once
			asset loader class would be where the meshes and textures live and are fetched by scene entities


================================
LECTURE 8 (week 3)
================================
Assimp api for importing fbx
	stands for asset import library or something
learn OpenGL is a core resource for learning to use it

Assimp imports a thing called something like an AiScene
	it has a mRootNode, mMeshes[], mMaterials[]

need to refactor our renderable set up
	to take into account the structure of Model & Mesh

	could do renderable is the base class for both
	but only models get added to scene

	this doesnt take into account sharing the loaded resource

	Entities and Components really helps fix this to make sharing

	an entity can have a mesh renderer
		and those mesh renderers can point to the same shared resources

		if the entity is just an int id for a collection of components, 
		and the compoenents are mostly just data, 
		it makes serializing the scene quite easy

INSTALLING ASSIMP 
	it is not header only, it is a library
	they have an installer, which should give you dlls and the lib
		the dll and the lib file should be all you need, 
		there are two libs, mtlib and mtdlib, one is for debug and one is for release
	try installing with cmake from git hub?

think about how to use the fbx model's parent node structure for display in heirarchy

THIS WEEK MIGHT BE THE ONLY TIME TO GET FBX IMPORT SET UP

emil will go over making an obj loader as well. 

================================
LECTURE 9 (week 4) mon UI
================================

module two is with Emil Hedemalm
	runs a small company Evergreen IT
		making iterum.gg

	did c++ in stockholm tripple a
	functional programming in fintech
	and cloud programming in transportation industry

week one 
	ui 
	parsed vs binary data, and obj loading
	managers, singletons, and messages

WHAT IS USER INTERFACE

connect core simulation to some kind of visuals

common tools in an engine editor,
	single asset editor
	map editor
	script or text editor
	test runner
	playtest mode

Other ui frameworks
	qt GUI,
	and GTK toolkit

	windows WPF

	Coherent gameface
		takes more of a html 

IMGUI
	
	IN THE LOOP
	make the windows and widgets
	at the end clean up

ENTITY MANAGEMENT

in this case:
	An Entity is something you can click and move around in the level editor of your game
	you may want to save it

	it is NOT
	sim data for particles
	simulation data for spawning enemies on the map
	strictly coupled to any one ui element


managing entities
	list or data struct of entitites 

	manager that can create and delete and stor ethe list of entities


visualizing entities
	3d part 
	ui part

might want a graphics manager that handles more complex which entities should render


first list of entities
	click on enity in ui
		selects it active for edititing, 
	button for create entity
	button for delete entity


	anonymous name spaces
	// .cpp
 
	// Anonymous namespace, only accessible in this .cpp-file
	namespace {
	  myAnonStuff.
	};

================================
LECTURE 10 (week 4) tue parsed vs binary data, and Obj
================================

data storage types are
	parsed files (text)
		csv
		json
		xml
		yaml (yet another markup language)	
			like python white space is used to create semantic structure
		wavefront.obj
		collada (xml based)
	binary files
		tell it how many bytes to read at time, char one byte, 2 or 4 bytes int, etc
		png
		fbx
		save files
		asset files that have been compressed and optimized
		audio files
		
Simple object loading
.obj
	list of vertices
	list of uv texture coords
	list of normals
	list of faces (using the indicies of above)

	VERTICES
	v 0.01 0.23 0.125 \n

triangulating

objIndices {0, 1, 2, 3}

for (size_t i = 1; i + 1 < objIndices.size(); i++)
 0 i i+1
=
0 1 2
0 2 3

================================
LECTURE 11 (week 4) ui mix. managers, singletons, and messages
================================

started with overview of student progress on obj loading

Mesh Manager!
	class or namespace
	MeshManager class is a singleton

review of what the singleton pattern is
	allocate during program initialization 
	use it in the main loop
	deallocate after the loop

how should managers communicate with eachother if things are threaded
poll system, check every frame
or message based system inform on completion

long slowprocess, 
	make sure process is itterative, only spend a butdget of the frame each frame and defer to next frame

	or perform task in another thread to ensure it doesn't impact the rest of the engine

graphics and physics on one thread, 
	visual feedback will be fluid

gameplay in one thread, 
	loading a save, or big asset happens here

operating system messaging need to be in their own thread since some of them need to be responded to immediately

NEED TO USE MUTEXES AND ATOMICS

break to work on tasks: entity swaping meshes in editor, and architecture planning

Messages
	any request or response between subsystems or managers of your engine

	one way to do it is to sub-class to extend a base class

	for example a raycast
		includes what is the ray, what were the hits

went over virtual destructors

important for asyn messaging messages are void since they may not finish immediately

Next task:
implement Msg queue

================================
LECTURE 12 (week 5) more resource management, textures, and models
================================

group code share

what is a resource
	models, meshes
	textures
	maps / levels
	scripts text
	nav mesh (binary)
	audio
	ui html, css, text, binary
	file handles
	network handles

Loading into memory an obj 
	open file
	read
	close file handle
	parse/ transform data
	load into graphics driver (opengl)
	free up some of the read or transformd data
	free gl resources (when needed or at end of program)

when do we need to free resources:
	free pre-emptively
	how much gpu memory do we need?
	inclue functions to check available memory for big allocations
	what do you do if there isn't enough memory?

example: low-poly mesh 1k tris
	obj. 3000 verts, normals and uvs, 4 bytes per numeric component of each.
	~ 96 kb for one model

memory limits
	what is reasonable 1 gb, 4gb?


OnWindows you can use GlobalMemoryStatusEx to querry how much physical memory is available

TASK1: add some functions to check available memory

TASK 2 make obj loader iterative
================================
LECTURE 13 (week 5) mesh loading optimization
================================

Tasks: serialize mesh as a binary.
	fps counter & timing of loads

about threads
	they allow concurency
	this alows better performance
	and allows responsiveness even while other threads are busy

these slides are old school check out dots engine notes for notes about thread pools and futures.

windows has WaitForSingleObject(mutex, max miliseconds to wait)
	if the mutex is free it passes the function

	if the mutex isn't free the thread will paus and wait 
	if the mutex is released before the miliseconds to wait it will go forward

MUST ReleaseMutex(mutex) after WaitForSingleObject() is done

Task 2: Thread some part of your engine